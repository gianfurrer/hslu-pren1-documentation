\documentclass[../main.tex]{subfiles}
\graphicspath{{\subfix{../img/}}}
\begin{document}

\newpage
\section{Simulator}

Der Simulator dient dazu, die Funktionalität der Software des autonomen Fahrzeugs zu testen, bevor der physische Prototyp gebaut wird. 

\subsection{Spezifikation}

In diesem Abschnitt wird definiert, was der Simulator genau leisten soll. Die Anforderungen stammen aus der Aufgabenstellung sowie dem gewählten Fahrzeugkonzept.

\begin{table}[htbp!]
    \centering
    \begin{tabularx}{\textwidth}{| l | X | l |}
        \hline
        \textbf{Nr.} & \textbf{Spezifikation} & \textbf{Priorität} \\ \hline
        1. & Es wird (ohne Beachtung der Hindernisse) immer der schnellste Weg ins Ziel gefunden. & Hoch \\ \hline
        2. & Entfernte Linien werden nicht befahren. & Hoch \\ \hline
        3. & Linien mit Hindernissen werden erkannt und nur befahren, falls ein Umweg länger dauert. & Hoch \\ \hline
        4. & Neue Informationen können während der Fahrt aufgenommen und entsprechende Strategie-Anpassungen dazu vorgenommen werden. & Hoch \\ \hline
        5. & Das Ziel kann konfiguriert werden (A, B oder C) & Hoch \\ \hline
        6. & Es gibt ein User Interface, welches den befahrenen Graphen aufzeigt. & Hoch \\ \hline
        6.1 & Im User Interface werden Pylonen, Hindernisse und entfernte Linien aufgezeigt & Mittel \\ \hline
        7. & Kommandos, die an die Hardware geschickt werden sollen, werden ausgegeben. & Mittel \\ \hline
        8. & Der Simulator analysiert den Graphen anhand von Bildern. & Tief \\ \hline
    \end{tabularx}
\end{table}

\newpage
\subsection{Morphologischer Kasten}

\newcolumntype{Y}{>{\centering\arraybackslash}X}

\begin{table}[htbp!]
    \centering
    \begin{tabularx}{\textwidth}{| X | Y | Y | Y |}
        \hline

        \rowcolor{LightGray}
        \textbf{Funktion} & \textbf{Option 1} & \textbf{Option 2} & \textbf{Option 3} \\ \hline
        
        \textbf{User Interface} &     
        Terminal \newline
        \includegraphics[width=2.5cm]{img/simulation/morphologischer-kasten/terminal.png}
        &
        \cellcolor{LightGreen}
        Einfaches GUI \newline
        \includegraphics[width=2.5cm]{img/simulation/morphologischer-kasten/simple-gui.png}
        &
        Unreal Engine \newline
        \includegraphics[width=2.5cm]{simulation/morphologischer-kasten/unreal-engine-logo.png}
        \\ \hline
        
        \textbf{Wegfindungs-Algorithmus}  &
        \cellcolor{LightGreen}
        Externe Bibliothek &
        Eigene Implementation &
        \\ \hline
        
        \textbf{Programmiersprache}      &
        \cellcolor{LightGreen}
        Python \newline
        \includegraphics[width=2.5cm]{simulation/morphologischer-kasten/python.png} 
        &
        JavaScript \newline
        \includegraphics[width=2.5cm]{simulation/morphologischer-kasten/javascript.png}
        &
        Java \newline
        \includegraphics[width=2.5cm]{simulation/morphologischer-kasten/java.png}
        \\ \hline
        
        \textbf{Informationen \newline einlesen}  &     
        Bilder mit Objekterkennung \newline
        \includegraphics[width=2.5cm]{img/simulation/morphologischer-kasten/ai-logo.jpg}
        &
        \cellcolor{LightGreen}
        Konfigurationsdatei \newline
        \includegraphics[width=2.5cm]{simulation/morphologischer-kasten/yaml.png}
        &
        \\ \hline
        
        \textbf{Hindernis \newline Bewältigung}   &     
        Immer umfahren \newline
        \includegraphics[width=3cm]{img/simulation/morphologischer-kasten/hindernis-umfahren.png}
        &
        Keine spezielle Behandlung \newline
        \includegraphics[width=3cm]{img/simulation/morphologischer-kasten/hindernis-ignoriert.png}
        &
        \cellcolor{LightGreen}
        Gewicht hinzufügen\newline
        \includegraphics[width=3cm]{img/simulation/morphologischer-kasten/hindernis-gewicht.png}
        \\ \hline
    \end{tabularx}
    \caption{Morphologischer Kasten - Simulator}
\end{table}

Der Lösungsansatz des Morphologischen Kastens ist darauf ausgelegt, einen simplen Simulator zu erstellen, welcher trotzdem viele Anforderungen an die Wegfindung abdecken kann.

\subsubsection{User Interface}

Obwohl wir ebenfalls eine virtuelle Umgebung mit der Unreal Engine und dem Pfadfinder-Model erstellen, wäre der Aufwand zu gross, diese an den Simulator anzubinden. Die Ausgabe in einem Terminal hingegen wäre zu minimal. Deshalb wird das User Interface mit einem einfachen GUI umgesetzt. 

\subsubsection{Wegfindungs-Algorithmus}

Der Wegfindungs-Algorithmus kann entweder selber oder mit Hilfe einer externen Bibliothek 
implementiert werden. Da für die Graphentheorie bereits viele beliebte Bibliotheken existieren, macht es für uns keinen Sinn, dies selbst zu implementieren. Zwar sind wir dadurch weniger flexibel, jedoch ist die Fehleranfälligkeit viel geringer.  

\subsubsection{Programmiersprache}

Bei der Programmiersprache kamen Python, JavaScript und Java in Frage.
Java wird für die meisten Projekte im Informatik-Studium verwendet. JavaScript erlaubt es, einfach graphische Darstellungen mittels Webseite zu implementieren. Python ist simpel und wird oft für Künstliche Intelligenz verwendet, was wir für die Implementation der Software des autonomen Fahrzeugs benötigen. 

Wir entscheiden uns für Python, da im Team viel know-how vorhanden ist. Ebenfalls bietet es mit NetworkX\footnote{https://networkx.org} eine mächtige Bibliothek für Graphen an.

\subsubsection{Informationen einlesen}

Damit die Software weiss, welche Hindernisse sich auf dem Graphen befindet, müssen Informationen eingelesen werden können. Idealerweise würde dies auf gleiche Art geschehen, wie in der Realität: anhand von Bildern mit Objekterkennung. Der Simulator soll jedoch so schnell wie möglich lauffähig sein, weshalb einfachkeitshalber eine Konfigurationsdatei mit den Informationen verwendet wird.

Die Konfigurationsdatei kann sehr einfach angepasst werden, wodurch man schnell viele Szenarien testen kann.

\subsubsection{Hindernis Bewältigung}

Der Simulator soll aufzeigen, wie mit Hindernissen umgegangen wird.
Hindernisse können eventuell nicht immer Umfahren werden, beispielsweise wenn alle anderen Pfade blockiert sind. Somit ist `Immer umfahren` keine gute Option. Hindernisse nicht speziell behandeln ist ebenfalls nicht optimal, da gleichlange Pfade ohne Hindernisse schneller durchfahren werden können. Deshalb verwenden wir die Option `Gewicht hinzufügen`. Dies erlaubt es uns, variabel zu entscheiden, wie viel Beachtung einem Hindernis geschenkt werden soll.

\subsection{Konzept}

Idealerweise würde der Simulator die komplette Hardware des autonomen Fahrzeuges simulieren. So wäre die Software, die auf dem Fahrzeug läuft, genau die gleiche, die vom Simulator getestet wird. Dies ist jedoch mit sehr viel Aufwand verbunden, weshalb dies für die erste Version des Simulators für uns nicht realisierbar ist.

Die erste Version des Simulators soll anhand einer vordefinierten Konfiguration den schnellsten Weg ins Ziel finden. Die Konfiguration enthält folgende Informationen:
\begin{itemize}
    \item Das Ziel: A, B oder C.
    \item Die Gewichtung für das Befahren von Linien mit einem Hindernis.
    \item Informationen die erst beim Befahren eines neuen Wegpunktes freigeschalten werden:
     \begin{itemize}
        \item{Wegpunkte mit einem Pylon}
        \item{Entfernte Linien}
        \item{Erkannte Hindernisse}
   \end{itemize}
\end{itemize}


Damit die Simulation weiss, auf welchen Wegpunkten bzw. Linien sich Hindernisse befinden, wird jeder Wegpunkt beschriftet:

\imagewidth{simulation/labeled-graph.png}{Beschrifteter Graph}{10cm}

Die Konfiguration wird in einer YAML\ref{yaml}-Datei abgespeichert und sieht wie folgt aus.

\begin{minted}[fontsize=\small]{yaml}
end: B
weight: 3
S:
  cones: [E]
  obstacles: 
    - [S, F] 
  removed:
    - [E, A]
D:
  removed:
    - [D, B]
  obstacles:
    - [D, A]
\end{minted}

In der Beispielkonfiguration wird das Ziel B angesteuert.
Eine Linie mit Hindernis wird dreifach gewichtet im Vergleich zu einer normaler Linie.  
Am Start (Knote S) erfährt die Software, dass auf dem Knoten E sich eine Pylone befindet,
auf der Linie S-F ein Hindernis und dass die Linie E-A entfernt wurde.
Falls das Fahrzeug die Kante D befährt, wird erkannt, dass die Kante D-B nicht existiert und dass sich auf Kante D-A ein Hindernis befindet.

Diese Konfiguration kann einfach angepasst werden, wodurch mit dem Simulator einfach verschiedene Szenarien durchgespielt werden können.

\subsection{Umsetzung}

Der Simulator 

Verwendete Bibliotheken:

\begin{itemize}
    \item NetworkX
    \item Matplotlib
\end{itemize}

\end{document}